# Generated from wkt.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,24,316,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,1,0,5,0,44,8,0,10,0,12,0,47,9,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,
        5,1,56,8,1,10,1,12,1,59,9,1,1,1,1,1,1,1,3,1,64,8,1,1,2,1,2,1,2,1,
        2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,3,2,80,8,2,1,3,1,3,3,3,
        84,8,3,1,3,1,3,1,3,1,3,1,3,3,3,91,8,3,1,4,1,4,1,4,1,5,1,5,1,5,1,
        6,1,6,1,6,1,6,1,6,3,6,104,8,6,1,6,1,6,1,6,1,6,3,6,110,8,6,5,6,112,
        8,6,10,6,12,6,115,9,6,1,6,1,6,1,6,3,6,120,8,6,1,7,1,7,1,7,1,7,3,
        7,126,8,7,1,7,1,7,1,7,3,7,131,8,7,5,7,133,8,7,10,7,12,7,136,9,7,
        1,7,1,7,1,7,3,7,141,8,7,1,8,1,8,1,8,1,8,1,8,3,8,148,8,8,1,8,1,8,
        1,8,1,8,3,8,154,8,8,5,8,156,8,8,10,8,12,8,159,9,8,1,8,1,8,1,8,3,
        8,164,8,8,1,9,1,9,1,9,1,9,3,9,170,8,9,1,9,1,9,1,9,3,9,175,8,9,5,
        9,177,8,9,10,9,12,9,180,9,9,1,9,1,9,1,9,3,9,185,8,9,1,10,1,10,1,
        10,1,10,1,10,5,10,192,8,10,10,10,12,10,195,9,10,1,10,1,10,1,10,3,
        10,200,8,10,1,11,1,11,1,11,1,11,1,11,5,11,207,8,11,10,11,12,11,210,
        9,11,1,11,1,11,1,11,3,11,215,8,11,1,12,1,12,1,12,1,12,1,12,5,12,
        222,8,12,10,12,12,12,225,9,12,1,12,1,12,1,12,3,12,230,8,12,1,13,
        1,13,1,13,1,13,1,13,5,13,237,8,13,10,13,12,13,240,9,13,1,13,1,13,
        1,13,3,13,245,8,13,1,14,1,14,1,14,1,14,1,14,5,14,252,8,14,10,14,
        12,14,255,9,14,1,14,1,14,1,14,3,14,260,8,14,1,15,1,15,1,15,1,15,
        1,15,5,15,267,8,15,10,15,12,15,270,9,15,1,15,1,15,1,16,1,16,1,16,
        1,16,1,16,3,16,279,8,16,1,17,1,17,1,17,1,17,5,17,285,8,17,10,17,
        12,17,288,9,17,1,17,1,17,1,17,3,17,293,8,17,1,18,1,18,1,18,1,18,
        5,18,299,8,18,10,18,12,18,302,9,18,1,18,1,18,1,18,3,18,307,8,18,
        1,19,4,19,310,8,19,11,19,12,19,311,1,20,1,20,1,20,0,0,21,0,2,4,6,
        8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,0,0,349,0,45,1,
        0,0,0,2,50,1,0,0,0,4,79,1,0,0,0,6,81,1,0,0,0,8,92,1,0,0,0,10,95,
        1,0,0,0,12,98,1,0,0,0,14,121,1,0,0,0,16,142,1,0,0,0,18,165,1,0,0,
        0,20,186,1,0,0,0,22,201,1,0,0,0,24,216,1,0,0,0,26,231,1,0,0,0,28,
        246,1,0,0,0,30,261,1,0,0,0,32,278,1,0,0,0,34,292,1,0,0,0,36,306,
        1,0,0,0,38,309,1,0,0,0,40,313,1,0,0,0,42,44,3,4,2,0,43,42,1,0,0,
        0,44,47,1,0,0,0,45,43,1,0,0,0,45,46,1,0,0,0,46,48,1,0,0,0,47,45,
        1,0,0,0,48,49,5,0,0,1,49,1,1,0,0,0,50,63,5,13,0,0,51,52,5,5,0,0,
        52,57,3,4,2,0,53,54,5,4,0,0,54,56,3,4,2,0,55,53,1,0,0,0,56,59,1,
        0,0,0,57,55,1,0,0,0,57,58,1,0,0,0,58,60,1,0,0,0,59,57,1,0,0,0,60,
        61,5,6,0,0,61,64,1,0,0,0,62,64,5,14,0,0,63,51,1,0,0,0,63,62,1,0,
        0,0,64,3,1,0,0,0,65,80,3,10,5,0,66,80,3,8,4,0,67,80,3,6,3,0,68,80,
        3,18,9,0,69,80,3,16,8,0,70,80,3,14,7,0,71,80,3,12,6,0,72,80,3,20,
        10,0,73,80,3,22,11,0,74,80,3,24,12,0,75,80,3,30,15,0,76,80,3,26,
        13,0,77,80,3,28,14,0,78,80,3,2,1,0,79,65,1,0,0,0,79,66,1,0,0,0,79,
        67,1,0,0,0,79,68,1,0,0,0,79,69,1,0,0,0,79,70,1,0,0,0,79,71,1,0,0,
        0,79,72,1,0,0,0,79,73,1,0,0,0,79,74,1,0,0,0,79,75,1,0,0,0,79,76,
        1,0,0,0,79,77,1,0,0,0,79,78,1,0,0,0,80,5,1,0,0,0,81,90,5,7,0,0,82,
        84,3,40,20,0,83,82,1,0,0,0,83,84,1,0,0,0,84,85,1,0,0,0,85,86,5,5,
        0,0,86,87,3,38,19,0,87,88,5,6,0,0,88,91,1,0,0,0,89,91,5,14,0,0,90,
        83,1,0,0,0,90,89,1,0,0,0,91,7,1,0,0,0,92,93,5,8,0,0,93,94,3,36,18,
        0,94,9,1,0,0,0,95,96,5,9,0,0,96,97,3,34,17,0,97,11,1,0,0,0,98,119,
        5,19,0,0,99,103,5,5,0,0,100,104,3,36,18,0,101,104,3,30,15,0,102,
        104,3,18,9,0,103,100,1,0,0,0,103,101,1,0,0,0,103,102,1,0,0,0,104,
        113,1,0,0,0,105,109,5,4,0,0,106,110,3,30,15,0,107,110,3,36,18,0,
        108,110,3,18,9,0,109,106,1,0,0,0,109,107,1,0,0,0,109,108,1,0,0,0,
        110,112,1,0,0,0,111,105,1,0,0,0,112,115,1,0,0,0,113,111,1,0,0,0,
        113,114,1,0,0,0,114,116,1,0,0,0,115,113,1,0,0,0,116,117,5,6,0,0,
        117,120,1,0,0,0,118,120,5,14,0,0,119,99,1,0,0,0,119,118,1,0,0,0,
        120,13,1,0,0,0,121,140,5,17,0,0,122,125,5,5,0,0,123,126,3,34,17,
        0,124,126,3,16,8,0,125,123,1,0,0,0,125,124,1,0,0,0,126,134,1,0,0,
        0,127,130,5,4,0,0,128,131,3,34,17,0,129,131,3,16,8,0,130,128,1,0,
        0,0,130,129,1,0,0,0,131,133,1,0,0,0,132,127,1,0,0,0,133,136,1,0,
        0,0,134,132,1,0,0,0,134,135,1,0,0,0,135,137,1,0,0,0,136,134,1,0,
        0,0,137,138,5,6,0,0,138,141,1,0,0,0,139,141,5,14,0,0,140,122,1,0,
        0,0,140,139,1,0,0,0,141,15,1,0,0,0,142,163,5,18,0,0,143,147,5,5,
        0,0,144,148,3,36,18,0,145,148,3,30,15,0,146,148,3,18,9,0,147,144,
        1,0,0,0,147,145,1,0,0,0,147,146,1,0,0,0,148,157,1,0,0,0,149,153,
        5,4,0,0,150,154,3,30,15,0,151,154,3,36,18,0,152,154,3,18,9,0,153,
        150,1,0,0,0,153,151,1,0,0,0,153,152,1,0,0,0,154,156,1,0,0,0,155,
        149,1,0,0,0,156,159,1,0,0,0,157,155,1,0,0,0,157,158,1,0,0,0,158,
        160,1,0,0,0,159,157,1,0,0,0,160,161,5,6,0,0,161,164,1,0,0,0,162,
        164,5,14,0,0,163,143,1,0,0,0,163,162,1,0,0,0,164,17,1,0,0,0,165,
        184,5,16,0,0,166,169,5,5,0,0,167,170,3,36,18,0,168,170,3,30,15,0,
        169,167,1,0,0,0,169,168,1,0,0,0,170,178,1,0,0,0,171,174,5,4,0,0,
        172,175,3,30,15,0,173,175,3,36,18,0,174,172,1,0,0,0,174,173,1,0,
        0,0,175,177,1,0,0,0,176,171,1,0,0,0,177,180,1,0,0,0,178,176,1,0,
        0,0,178,179,1,0,0,0,179,181,1,0,0,0,180,178,1,0,0,0,181,182,5,6,
        0,0,182,185,1,0,0,0,183,185,5,14,0,0,184,166,1,0,0,0,184,183,1,0,
        0,0,185,19,1,0,0,0,186,199,5,10,0,0,187,188,5,5,0,0,188,193,3,32,
        16,0,189,190,5,4,0,0,190,192,3,32,16,0,191,189,1,0,0,0,192,195,1,
        0,0,0,193,191,1,0,0,0,193,194,1,0,0,0,194,196,1,0,0,0,195,193,1,
        0,0,0,196,197,5,6,0,0,197,200,1,0,0,0,198,200,5,14,0,0,199,187,1,
        0,0,0,199,198,1,0,0,0,200,21,1,0,0,0,201,214,5,11,0,0,202,203,5,
        5,0,0,203,208,3,36,18,0,204,205,5,4,0,0,205,207,3,36,18,0,206,204,
        1,0,0,0,207,210,1,0,0,0,208,206,1,0,0,0,208,209,1,0,0,0,209,211,
        1,0,0,0,210,208,1,0,0,0,211,212,5,6,0,0,212,215,1,0,0,0,213,215,
        5,14,0,0,214,202,1,0,0,0,214,213,1,0,0,0,215,23,1,0,0,0,216,229,
        5,12,0,0,217,218,5,5,0,0,218,223,3,34,17,0,219,220,5,4,0,0,220,222,
        3,34,17,0,221,219,1,0,0,0,222,225,1,0,0,0,223,221,1,0,0,0,223,224,
        1,0,0,0,224,226,1,0,0,0,225,223,1,0,0,0,226,227,5,6,0,0,227,230,
        1,0,0,0,228,230,5,14,0,0,229,217,1,0,0,0,229,228,1,0,0,0,230,25,
        1,0,0,0,231,244,5,22,0,0,232,233,5,5,0,0,233,238,3,34,17,0,234,235,
        5,4,0,0,235,237,3,34,17,0,236,234,1,0,0,0,237,240,1,0,0,0,238,236,
        1,0,0,0,238,239,1,0,0,0,239,241,1,0,0,0,240,238,1,0,0,0,241,242,
        5,6,0,0,242,245,1,0,0,0,243,245,5,14,0,0,244,232,1,0,0,0,244,243,
        1,0,0,0,245,27,1,0,0,0,246,259,5,21,0,0,247,248,5,5,0,0,248,253,
        3,34,17,0,249,250,5,4,0,0,250,252,3,34,17,0,251,249,1,0,0,0,252,
        255,1,0,0,0,253,251,1,0,0,0,253,254,1,0,0,0,254,256,1,0,0,0,255,
        253,1,0,0,0,256,257,5,6,0,0,257,260,1,0,0,0,258,260,5,14,0,0,259,
        247,1,0,0,0,259,258,1,0,0,0,260,29,1,0,0,0,261,262,5,15,0,0,262,
        263,5,5,0,0,263,268,3,38,19,0,264,265,5,4,0,0,265,267,3,38,19,0,
        266,264,1,0,0,0,267,270,1,0,0,0,268,266,1,0,0,0,268,269,1,0,0,0,
        269,271,1,0,0,0,270,268,1,0,0,0,271,272,5,6,0,0,272,31,1,0,0,0,273,
        279,3,38,19,0,274,275,5,5,0,0,275,276,3,38,19,0,276,277,5,6,0,0,
        277,279,1,0,0,0,278,273,1,0,0,0,278,274,1,0,0,0,279,33,1,0,0,0,280,
        281,5,5,0,0,281,286,3,36,18,0,282,283,5,4,0,0,283,285,3,36,18,0,
        284,282,1,0,0,0,285,288,1,0,0,0,286,284,1,0,0,0,286,287,1,0,0,0,
        287,289,1,0,0,0,288,286,1,0,0,0,289,290,5,6,0,0,290,293,1,0,0,0,
        291,293,5,14,0,0,292,280,1,0,0,0,292,291,1,0,0,0,293,35,1,0,0,0,
        294,295,5,5,0,0,295,300,3,38,19,0,296,297,5,4,0,0,297,299,3,38,19,
        0,298,296,1,0,0,0,299,302,1,0,0,0,300,298,1,0,0,0,300,301,1,0,0,
        0,301,303,1,0,0,0,302,300,1,0,0,0,303,304,5,6,0,0,304,307,1,0,0,
        0,305,307,5,14,0,0,306,294,1,0,0,0,306,305,1,0,0,0,307,37,1,0,0,
        0,308,310,5,1,0,0,309,308,1,0,0,0,310,311,1,0,0,0,311,309,1,0,0,
        0,311,312,1,0,0,0,312,39,1,0,0,0,313,314,5,23,0,0,314,41,1,0,0,0,
        39,45,57,63,79,83,90,103,109,113,119,125,130,134,140,147,153,157,
        163,169,174,178,184,193,199,208,214,223,229,238,244,253,259,268,
        278,286,292,300,306,311
    ]

class wktParser ( Parser ):

    grammarFileName = "wkt.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "','", "'('", "')'" ]

    symbolicNames = [ "<INVALID>", "DECIMAL", "INTEGERPART", "DECIMALPART", 
                      "COMMA", "LPAR", "RPAR", "POINT", "LINESTRING", "POLYGON", 
                      "MULTIPOINT", "MULTILINESTRING", "MULTIPOLYGON", "GEOMETRYCOLLECTION", 
                      "EMPTY_", "CIRCULARSTRING", "COMPOUNDCURVE", "MULTISURFACE", 
                      "CURVEPOLYGON", "MULTICURVE", "TRIANGLE", "TIN", "POLYHEDRALSURFACE", 
                      "STRING", "WS" ]

    RULE_file_ = 0
    RULE_geometryCollection = 1
    RULE_geometry = 2
    RULE_pointGeometry = 3
    RULE_lineStringGeometry = 4
    RULE_polygonGeometry = 5
    RULE_multiCurveGeometry = 6
    RULE_multiSurfaceGeometry = 7
    RULE_curvePolygonGeometry = 8
    RULE_compoundCurveGeometry = 9
    RULE_multiPointGeometry = 10
    RULE_multiLineStringGeometry = 11
    RULE_multiPolygonGeometry = 12
    RULE_multiPolyhedralSurfaceGeometry = 13
    RULE_multiTinGeometry = 14
    RULE_circularStringGeometry = 15
    RULE_pointOrClosedPoint = 16
    RULE_polygon = 17
    RULE_lineString = 18
    RULE_point = 19
    RULE_name = 20

    ruleNames =  [ "file_", "geometryCollection", "geometry", "pointGeometry", 
                   "lineStringGeometry", "polygonGeometry", "multiCurveGeometry", 
                   "multiSurfaceGeometry", "curvePolygonGeometry", "compoundCurveGeometry", 
                   "multiPointGeometry", "multiLineStringGeometry", "multiPolygonGeometry", 
                   "multiPolyhedralSurfaceGeometry", "multiTinGeometry", 
                   "circularStringGeometry", "pointOrClosedPoint", "polygon", 
                   "lineString", "point", "name" ]

    EOF = Token.EOF
    DECIMAL=1
    INTEGERPART=2
    DECIMALPART=3
    COMMA=4
    LPAR=5
    RPAR=6
    POINT=7
    LINESTRING=8
    POLYGON=9
    MULTIPOINT=10
    MULTILINESTRING=11
    MULTIPOLYGON=12
    GEOMETRYCOLLECTION=13
    EMPTY_=14
    CIRCULARSTRING=15
    COMPOUNDCURVE=16
    MULTISURFACE=17
    CURVEPOLYGON=18
    MULTICURVE=19
    TRIANGLE=20
    TIN=21
    POLYHEDRALSURFACE=22
    STRING=23
    WS=24

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class File_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(wktParser.EOF, 0)

        def geometry(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(wktParser.GeometryContext)
            else:
                return self.getTypedRuleContext(wktParser.GeometryContext,i)


        def getRuleIndex(self):
            return wktParser.RULE_file_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFile_" ):
                listener.enterFile_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFile_" ):
                listener.exitFile_(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFile_" ):
                return visitor.visitFile_(self)
            else:
                return visitor.visitChildren(self)




    def file_(self):

        localctx = wktParser.File_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_file_)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 45
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 7323520) != 0):
                self.state = 42
                self.geometry()
                self.state = 47
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 48
            self.match(wktParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GeometryCollectionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GEOMETRYCOLLECTION(self):
            return self.getToken(wktParser.GEOMETRYCOLLECTION, 0)

        def LPAR(self):
            return self.getToken(wktParser.LPAR, 0)

        def geometry(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(wktParser.GeometryContext)
            else:
                return self.getTypedRuleContext(wktParser.GeometryContext,i)


        def RPAR(self):
            return self.getToken(wktParser.RPAR, 0)

        def EMPTY_(self):
            return self.getToken(wktParser.EMPTY_, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(wktParser.COMMA)
            else:
                return self.getToken(wktParser.COMMA, i)

        def getRuleIndex(self):
            return wktParser.RULE_geometryCollection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeometryCollection" ):
                listener.enterGeometryCollection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeometryCollection" ):
                listener.exitGeometryCollection(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGeometryCollection" ):
                return visitor.visitGeometryCollection(self)
            else:
                return visitor.visitChildren(self)




    def geometryCollection(self):

        localctx = wktParser.GeometryCollectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_geometryCollection)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 50
            self.match(wktParser.GEOMETRYCOLLECTION)
            self.state = 63
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5]:
                self.state = 51
                self.match(wktParser.LPAR)
                self.state = 52
                self.geometry()
                self.state = 57
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==4:
                    self.state = 53
                    self.match(wktParser.COMMA)
                    self.state = 54
                    self.geometry()
                    self.state = 59
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 60
                self.match(wktParser.RPAR)
                pass
            elif token in [14]:
                self.state = 62
                self.match(wktParser.EMPTY_)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GeometryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def polygonGeometry(self):
            return self.getTypedRuleContext(wktParser.PolygonGeometryContext,0)


        def lineStringGeometry(self):
            return self.getTypedRuleContext(wktParser.LineStringGeometryContext,0)


        def pointGeometry(self):
            return self.getTypedRuleContext(wktParser.PointGeometryContext,0)


        def compoundCurveGeometry(self):
            return self.getTypedRuleContext(wktParser.CompoundCurveGeometryContext,0)


        def curvePolygonGeometry(self):
            return self.getTypedRuleContext(wktParser.CurvePolygonGeometryContext,0)


        def multiSurfaceGeometry(self):
            return self.getTypedRuleContext(wktParser.MultiSurfaceGeometryContext,0)


        def multiCurveGeometry(self):
            return self.getTypedRuleContext(wktParser.MultiCurveGeometryContext,0)


        def multiPointGeometry(self):
            return self.getTypedRuleContext(wktParser.MultiPointGeometryContext,0)


        def multiLineStringGeometry(self):
            return self.getTypedRuleContext(wktParser.MultiLineStringGeometryContext,0)


        def multiPolygonGeometry(self):
            return self.getTypedRuleContext(wktParser.MultiPolygonGeometryContext,0)


        def circularStringGeometry(self):
            return self.getTypedRuleContext(wktParser.CircularStringGeometryContext,0)


        def multiPolyhedralSurfaceGeometry(self):
            return self.getTypedRuleContext(wktParser.MultiPolyhedralSurfaceGeometryContext,0)


        def multiTinGeometry(self):
            return self.getTypedRuleContext(wktParser.MultiTinGeometryContext,0)


        def geometryCollection(self):
            return self.getTypedRuleContext(wktParser.GeometryCollectionContext,0)


        def getRuleIndex(self):
            return wktParser.RULE_geometry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeometry" ):
                listener.enterGeometry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeometry" ):
                listener.exitGeometry(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGeometry" ):
                return visitor.visitGeometry(self)
            else:
                return visitor.visitChildren(self)




    def geometry(self):

        localctx = wktParser.GeometryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_geometry)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 79
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [9]:
                self.state = 65
                self.polygonGeometry()
                pass
            elif token in [8]:
                self.state = 66
                self.lineStringGeometry()
                pass
            elif token in [7]:
                self.state = 67
                self.pointGeometry()
                pass
            elif token in [16]:
                self.state = 68
                self.compoundCurveGeometry()
                pass
            elif token in [18]:
                self.state = 69
                self.curvePolygonGeometry()
                pass
            elif token in [17]:
                self.state = 70
                self.multiSurfaceGeometry()
                pass
            elif token in [19]:
                self.state = 71
                self.multiCurveGeometry()
                pass
            elif token in [10]:
                self.state = 72
                self.multiPointGeometry()
                pass
            elif token in [11]:
                self.state = 73
                self.multiLineStringGeometry()
                pass
            elif token in [12]:
                self.state = 74
                self.multiPolygonGeometry()
                pass
            elif token in [15]:
                self.state = 75
                self.circularStringGeometry()
                pass
            elif token in [22]:
                self.state = 76
                self.multiPolyhedralSurfaceGeometry()
                pass
            elif token in [21]:
                self.state = 77
                self.multiTinGeometry()
                pass
            elif token in [13]:
                self.state = 78
                self.geometryCollection()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PointGeometryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POINT(self):
            return self.getToken(wktParser.POINT, 0)

        def EMPTY_(self):
            return self.getToken(wktParser.EMPTY_, 0)

        def LPAR(self):
            return self.getToken(wktParser.LPAR, 0)

        def point(self):
            return self.getTypedRuleContext(wktParser.PointContext,0)


        def RPAR(self):
            return self.getToken(wktParser.RPAR, 0)

        def name(self):
            return self.getTypedRuleContext(wktParser.NameContext,0)


        def getRuleIndex(self):
            return wktParser.RULE_pointGeometry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPointGeometry" ):
                listener.enterPointGeometry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPointGeometry" ):
                listener.exitPointGeometry(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPointGeometry" ):
                return visitor.visitPointGeometry(self)
            else:
                return visitor.visitChildren(self)




    def pointGeometry(self):

        localctx = wktParser.PointGeometryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_pointGeometry)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 81
            self.match(wktParser.POINT)
            self.state = 90
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5, 23]:
                self.state = 83
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==23:
                    self.state = 82
                    self.name()


                self.state = 85
                self.match(wktParser.LPAR)
                self.state = 86
                self.point()
                self.state = 87
                self.match(wktParser.RPAR)
                pass
            elif token in [14]:
                self.state = 89
                self.match(wktParser.EMPTY_)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LineStringGeometryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LINESTRING(self):
            return self.getToken(wktParser.LINESTRING, 0)

        def lineString(self):
            return self.getTypedRuleContext(wktParser.LineStringContext,0)


        def getRuleIndex(self):
            return wktParser.RULE_lineStringGeometry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLineStringGeometry" ):
                listener.enterLineStringGeometry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLineStringGeometry" ):
                listener.exitLineStringGeometry(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLineStringGeometry" ):
                return visitor.visitLineStringGeometry(self)
            else:
                return visitor.visitChildren(self)




    def lineStringGeometry(self):

        localctx = wktParser.LineStringGeometryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_lineStringGeometry)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 92
            self.match(wktParser.LINESTRING)
            self.state = 93
            self.lineString()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolygonGeometryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POLYGON(self):
            return self.getToken(wktParser.POLYGON, 0)

        def polygon(self):
            return self.getTypedRuleContext(wktParser.PolygonContext,0)


        def getRuleIndex(self):
            return wktParser.RULE_polygonGeometry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolygonGeometry" ):
                listener.enterPolygonGeometry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolygonGeometry" ):
                listener.exitPolygonGeometry(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPolygonGeometry" ):
                return visitor.visitPolygonGeometry(self)
            else:
                return visitor.visitChildren(self)




    def polygonGeometry(self):

        localctx = wktParser.PolygonGeometryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_polygonGeometry)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 95
            self.match(wktParser.POLYGON)
            self.state = 96
            self.polygon()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiCurveGeometryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MULTICURVE(self):
            return self.getToken(wktParser.MULTICURVE, 0)

        def EMPTY_(self):
            return self.getToken(wktParser.EMPTY_, 0)

        def LPAR(self):
            return self.getToken(wktParser.LPAR, 0)

        def RPAR(self):
            return self.getToken(wktParser.RPAR, 0)

        def lineString(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(wktParser.LineStringContext)
            else:
                return self.getTypedRuleContext(wktParser.LineStringContext,i)


        def circularStringGeometry(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(wktParser.CircularStringGeometryContext)
            else:
                return self.getTypedRuleContext(wktParser.CircularStringGeometryContext,i)


        def compoundCurveGeometry(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(wktParser.CompoundCurveGeometryContext)
            else:
                return self.getTypedRuleContext(wktParser.CompoundCurveGeometryContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(wktParser.COMMA)
            else:
                return self.getToken(wktParser.COMMA, i)

        def getRuleIndex(self):
            return wktParser.RULE_multiCurveGeometry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiCurveGeometry" ):
                listener.enterMultiCurveGeometry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiCurveGeometry" ):
                listener.exitMultiCurveGeometry(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiCurveGeometry" ):
                return visitor.visitMultiCurveGeometry(self)
            else:
                return visitor.visitChildren(self)




    def multiCurveGeometry(self):

        localctx = wktParser.MultiCurveGeometryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_multiCurveGeometry)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 98
            self.match(wktParser.MULTICURVE)
            self.state = 119
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5]:
                self.state = 99
                self.match(wktParser.LPAR)
                self.state = 103
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [5, 14]:
                    self.state = 100
                    self.lineString()
                    pass
                elif token in [15]:
                    self.state = 101
                    self.circularStringGeometry()
                    pass
                elif token in [16]:
                    self.state = 102
                    self.compoundCurveGeometry()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 113
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==4:
                    self.state = 105
                    self.match(wktParser.COMMA)
                    self.state = 109
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [15]:
                        self.state = 106
                        self.circularStringGeometry()
                        pass
                    elif token in [5, 14]:
                        self.state = 107
                        self.lineString()
                        pass
                    elif token in [16]:
                        self.state = 108
                        self.compoundCurveGeometry()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 115
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 116
                self.match(wktParser.RPAR)
                pass
            elif token in [14]:
                self.state = 118
                self.match(wktParser.EMPTY_)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiSurfaceGeometryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MULTISURFACE(self):
            return self.getToken(wktParser.MULTISURFACE, 0)

        def EMPTY_(self):
            return self.getToken(wktParser.EMPTY_, 0)

        def LPAR(self):
            return self.getToken(wktParser.LPAR, 0)

        def RPAR(self):
            return self.getToken(wktParser.RPAR, 0)

        def polygon(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(wktParser.PolygonContext)
            else:
                return self.getTypedRuleContext(wktParser.PolygonContext,i)


        def curvePolygonGeometry(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(wktParser.CurvePolygonGeometryContext)
            else:
                return self.getTypedRuleContext(wktParser.CurvePolygonGeometryContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(wktParser.COMMA)
            else:
                return self.getToken(wktParser.COMMA, i)

        def getRuleIndex(self):
            return wktParser.RULE_multiSurfaceGeometry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiSurfaceGeometry" ):
                listener.enterMultiSurfaceGeometry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiSurfaceGeometry" ):
                listener.exitMultiSurfaceGeometry(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiSurfaceGeometry" ):
                return visitor.visitMultiSurfaceGeometry(self)
            else:
                return visitor.visitChildren(self)




    def multiSurfaceGeometry(self):

        localctx = wktParser.MultiSurfaceGeometryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_multiSurfaceGeometry)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 121
            self.match(wktParser.MULTISURFACE)
            self.state = 140
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5]:
                self.state = 122
                self.match(wktParser.LPAR)
                self.state = 125
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [5, 14]:
                    self.state = 123
                    self.polygon()
                    pass
                elif token in [18]:
                    self.state = 124
                    self.curvePolygonGeometry()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 134
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==4:
                    self.state = 127
                    self.match(wktParser.COMMA)
                    self.state = 130
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [5, 14]:
                        self.state = 128
                        self.polygon()
                        pass
                    elif token in [18]:
                        self.state = 129
                        self.curvePolygonGeometry()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 136
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 137
                self.match(wktParser.RPAR)
                pass
            elif token in [14]:
                self.state = 139
                self.match(wktParser.EMPTY_)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CurvePolygonGeometryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CURVEPOLYGON(self):
            return self.getToken(wktParser.CURVEPOLYGON, 0)

        def EMPTY_(self):
            return self.getToken(wktParser.EMPTY_, 0)

        def LPAR(self):
            return self.getToken(wktParser.LPAR, 0)

        def RPAR(self):
            return self.getToken(wktParser.RPAR, 0)

        def lineString(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(wktParser.LineStringContext)
            else:
                return self.getTypedRuleContext(wktParser.LineStringContext,i)


        def circularStringGeometry(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(wktParser.CircularStringGeometryContext)
            else:
                return self.getTypedRuleContext(wktParser.CircularStringGeometryContext,i)


        def compoundCurveGeometry(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(wktParser.CompoundCurveGeometryContext)
            else:
                return self.getTypedRuleContext(wktParser.CompoundCurveGeometryContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(wktParser.COMMA)
            else:
                return self.getToken(wktParser.COMMA, i)

        def getRuleIndex(self):
            return wktParser.RULE_curvePolygonGeometry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCurvePolygonGeometry" ):
                listener.enterCurvePolygonGeometry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCurvePolygonGeometry" ):
                listener.exitCurvePolygonGeometry(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCurvePolygonGeometry" ):
                return visitor.visitCurvePolygonGeometry(self)
            else:
                return visitor.visitChildren(self)




    def curvePolygonGeometry(self):

        localctx = wktParser.CurvePolygonGeometryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_curvePolygonGeometry)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 142
            self.match(wktParser.CURVEPOLYGON)
            self.state = 163
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5]:
                self.state = 143
                self.match(wktParser.LPAR)
                self.state = 147
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [5, 14]:
                    self.state = 144
                    self.lineString()
                    pass
                elif token in [15]:
                    self.state = 145
                    self.circularStringGeometry()
                    pass
                elif token in [16]:
                    self.state = 146
                    self.compoundCurveGeometry()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 157
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==4:
                    self.state = 149
                    self.match(wktParser.COMMA)
                    self.state = 153
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [15]:
                        self.state = 150
                        self.circularStringGeometry()
                        pass
                    elif token in [5, 14]:
                        self.state = 151
                        self.lineString()
                        pass
                    elif token in [16]:
                        self.state = 152
                        self.compoundCurveGeometry()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 159
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 160
                self.match(wktParser.RPAR)
                pass
            elif token in [14]:
                self.state = 162
                self.match(wktParser.EMPTY_)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompoundCurveGeometryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMPOUNDCURVE(self):
            return self.getToken(wktParser.COMPOUNDCURVE, 0)

        def EMPTY_(self):
            return self.getToken(wktParser.EMPTY_, 0)

        def LPAR(self):
            return self.getToken(wktParser.LPAR, 0)

        def RPAR(self):
            return self.getToken(wktParser.RPAR, 0)

        def lineString(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(wktParser.LineStringContext)
            else:
                return self.getTypedRuleContext(wktParser.LineStringContext,i)


        def circularStringGeometry(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(wktParser.CircularStringGeometryContext)
            else:
                return self.getTypedRuleContext(wktParser.CircularStringGeometryContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(wktParser.COMMA)
            else:
                return self.getToken(wktParser.COMMA, i)

        def getRuleIndex(self):
            return wktParser.RULE_compoundCurveGeometry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompoundCurveGeometry" ):
                listener.enterCompoundCurveGeometry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompoundCurveGeometry" ):
                listener.exitCompoundCurveGeometry(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompoundCurveGeometry" ):
                return visitor.visitCompoundCurveGeometry(self)
            else:
                return visitor.visitChildren(self)




    def compoundCurveGeometry(self):

        localctx = wktParser.CompoundCurveGeometryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_compoundCurveGeometry)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 165
            self.match(wktParser.COMPOUNDCURVE)
            self.state = 184
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5]:
                self.state = 166
                self.match(wktParser.LPAR)
                self.state = 169
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [5, 14]:
                    self.state = 167
                    self.lineString()
                    pass
                elif token in [15]:
                    self.state = 168
                    self.circularStringGeometry()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 178
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==4:
                    self.state = 171
                    self.match(wktParser.COMMA)
                    self.state = 174
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [15]:
                        self.state = 172
                        self.circularStringGeometry()
                        pass
                    elif token in [5, 14]:
                        self.state = 173
                        self.lineString()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 180
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 181
                self.match(wktParser.RPAR)
                pass
            elif token in [14]:
                self.state = 183
                self.match(wktParser.EMPTY_)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiPointGeometryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MULTIPOINT(self):
            return self.getToken(wktParser.MULTIPOINT, 0)

        def EMPTY_(self):
            return self.getToken(wktParser.EMPTY_, 0)

        def LPAR(self):
            return self.getToken(wktParser.LPAR, 0)

        def pointOrClosedPoint(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(wktParser.PointOrClosedPointContext)
            else:
                return self.getTypedRuleContext(wktParser.PointOrClosedPointContext,i)


        def RPAR(self):
            return self.getToken(wktParser.RPAR, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(wktParser.COMMA)
            else:
                return self.getToken(wktParser.COMMA, i)

        def getRuleIndex(self):
            return wktParser.RULE_multiPointGeometry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiPointGeometry" ):
                listener.enterMultiPointGeometry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiPointGeometry" ):
                listener.exitMultiPointGeometry(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiPointGeometry" ):
                return visitor.visitMultiPointGeometry(self)
            else:
                return visitor.visitChildren(self)




    def multiPointGeometry(self):

        localctx = wktParser.MultiPointGeometryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_multiPointGeometry)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 186
            self.match(wktParser.MULTIPOINT)
            self.state = 199
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5]:
                self.state = 187
                self.match(wktParser.LPAR)
                self.state = 188
                self.pointOrClosedPoint()
                self.state = 193
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==4:
                    self.state = 189
                    self.match(wktParser.COMMA)
                    self.state = 190
                    self.pointOrClosedPoint()
                    self.state = 195
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 196
                self.match(wktParser.RPAR)
                pass
            elif token in [14]:
                self.state = 198
                self.match(wktParser.EMPTY_)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiLineStringGeometryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MULTILINESTRING(self):
            return self.getToken(wktParser.MULTILINESTRING, 0)

        def EMPTY_(self):
            return self.getToken(wktParser.EMPTY_, 0)

        def LPAR(self):
            return self.getToken(wktParser.LPAR, 0)

        def lineString(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(wktParser.LineStringContext)
            else:
                return self.getTypedRuleContext(wktParser.LineStringContext,i)


        def RPAR(self):
            return self.getToken(wktParser.RPAR, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(wktParser.COMMA)
            else:
                return self.getToken(wktParser.COMMA, i)

        def getRuleIndex(self):
            return wktParser.RULE_multiLineStringGeometry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiLineStringGeometry" ):
                listener.enterMultiLineStringGeometry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiLineStringGeometry" ):
                listener.exitMultiLineStringGeometry(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiLineStringGeometry" ):
                return visitor.visitMultiLineStringGeometry(self)
            else:
                return visitor.visitChildren(self)




    def multiLineStringGeometry(self):

        localctx = wktParser.MultiLineStringGeometryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_multiLineStringGeometry)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 201
            self.match(wktParser.MULTILINESTRING)
            self.state = 214
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5]:
                self.state = 202
                self.match(wktParser.LPAR)
                self.state = 203
                self.lineString()
                self.state = 208
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==4:
                    self.state = 204
                    self.match(wktParser.COMMA)
                    self.state = 205
                    self.lineString()
                    self.state = 210
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 211
                self.match(wktParser.RPAR)
                pass
            elif token in [14]:
                self.state = 213
                self.match(wktParser.EMPTY_)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiPolygonGeometryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MULTIPOLYGON(self):
            return self.getToken(wktParser.MULTIPOLYGON, 0)

        def EMPTY_(self):
            return self.getToken(wktParser.EMPTY_, 0)

        def LPAR(self):
            return self.getToken(wktParser.LPAR, 0)

        def polygon(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(wktParser.PolygonContext)
            else:
                return self.getTypedRuleContext(wktParser.PolygonContext,i)


        def RPAR(self):
            return self.getToken(wktParser.RPAR, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(wktParser.COMMA)
            else:
                return self.getToken(wktParser.COMMA, i)

        def getRuleIndex(self):
            return wktParser.RULE_multiPolygonGeometry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiPolygonGeometry" ):
                listener.enterMultiPolygonGeometry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiPolygonGeometry" ):
                listener.exitMultiPolygonGeometry(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiPolygonGeometry" ):
                return visitor.visitMultiPolygonGeometry(self)
            else:
                return visitor.visitChildren(self)




    def multiPolygonGeometry(self):

        localctx = wktParser.MultiPolygonGeometryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_multiPolygonGeometry)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 216
            self.match(wktParser.MULTIPOLYGON)
            self.state = 229
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5]:
                self.state = 217
                self.match(wktParser.LPAR)
                self.state = 218
                self.polygon()
                self.state = 223
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==4:
                    self.state = 219
                    self.match(wktParser.COMMA)
                    self.state = 220
                    self.polygon()
                    self.state = 225
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 226
                self.match(wktParser.RPAR)
                pass
            elif token in [14]:
                self.state = 228
                self.match(wktParser.EMPTY_)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiPolyhedralSurfaceGeometryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POLYHEDRALSURFACE(self):
            return self.getToken(wktParser.POLYHEDRALSURFACE, 0)

        def EMPTY_(self):
            return self.getToken(wktParser.EMPTY_, 0)

        def LPAR(self):
            return self.getToken(wktParser.LPAR, 0)

        def polygon(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(wktParser.PolygonContext)
            else:
                return self.getTypedRuleContext(wktParser.PolygonContext,i)


        def RPAR(self):
            return self.getToken(wktParser.RPAR, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(wktParser.COMMA)
            else:
                return self.getToken(wktParser.COMMA, i)

        def getRuleIndex(self):
            return wktParser.RULE_multiPolyhedralSurfaceGeometry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiPolyhedralSurfaceGeometry" ):
                listener.enterMultiPolyhedralSurfaceGeometry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiPolyhedralSurfaceGeometry" ):
                listener.exitMultiPolyhedralSurfaceGeometry(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiPolyhedralSurfaceGeometry" ):
                return visitor.visitMultiPolyhedralSurfaceGeometry(self)
            else:
                return visitor.visitChildren(self)




    def multiPolyhedralSurfaceGeometry(self):

        localctx = wktParser.MultiPolyhedralSurfaceGeometryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_multiPolyhedralSurfaceGeometry)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 231
            self.match(wktParser.POLYHEDRALSURFACE)
            self.state = 244
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5]:
                self.state = 232
                self.match(wktParser.LPAR)
                self.state = 233
                self.polygon()
                self.state = 238
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==4:
                    self.state = 234
                    self.match(wktParser.COMMA)
                    self.state = 235
                    self.polygon()
                    self.state = 240
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 241
                self.match(wktParser.RPAR)
                pass
            elif token in [14]:
                self.state = 243
                self.match(wktParser.EMPTY_)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiTinGeometryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TIN(self):
            return self.getToken(wktParser.TIN, 0)

        def EMPTY_(self):
            return self.getToken(wktParser.EMPTY_, 0)

        def LPAR(self):
            return self.getToken(wktParser.LPAR, 0)

        def polygon(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(wktParser.PolygonContext)
            else:
                return self.getTypedRuleContext(wktParser.PolygonContext,i)


        def RPAR(self):
            return self.getToken(wktParser.RPAR, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(wktParser.COMMA)
            else:
                return self.getToken(wktParser.COMMA, i)

        def getRuleIndex(self):
            return wktParser.RULE_multiTinGeometry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiTinGeometry" ):
                listener.enterMultiTinGeometry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiTinGeometry" ):
                listener.exitMultiTinGeometry(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiTinGeometry" ):
                return visitor.visitMultiTinGeometry(self)
            else:
                return visitor.visitChildren(self)




    def multiTinGeometry(self):

        localctx = wktParser.MultiTinGeometryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_multiTinGeometry)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 246
            self.match(wktParser.TIN)
            self.state = 259
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5]:
                self.state = 247
                self.match(wktParser.LPAR)
                self.state = 248
                self.polygon()
                self.state = 253
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==4:
                    self.state = 249
                    self.match(wktParser.COMMA)
                    self.state = 250
                    self.polygon()
                    self.state = 255
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 256
                self.match(wktParser.RPAR)
                pass
            elif token in [14]:
                self.state = 258
                self.match(wktParser.EMPTY_)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CircularStringGeometryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CIRCULARSTRING(self):
            return self.getToken(wktParser.CIRCULARSTRING, 0)

        def LPAR(self):
            return self.getToken(wktParser.LPAR, 0)

        def point(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(wktParser.PointContext)
            else:
                return self.getTypedRuleContext(wktParser.PointContext,i)


        def RPAR(self):
            return self.getToken(wktParser.RPAR, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(wktParser.COMMA)
            else:
                return self.getToken(wktParser.COMMA, i)

        def getRuleIndex(self):
            return wktParser.RULE_circularStringGeometry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCircularStringGeometry" ):
                listener.enterCircularStringGeometry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCircularStringGeometry" ):
                listener.exitCircularStringGeometry(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCircularStringGeometry" ):
                return visitor.visitCircularStringGeometry(self)
            else:
                return visitor.visitChildren(self)




    def circularStringGeometry(self):

        localctx = wktParser.CircularStringGeometryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_circularStringGeometry)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 261
            self.match(wktParser.CIRCULARSTRING)
            self.state = 262
            self.match(wktParser.LPAR)
            self.state = 263
            self.point()
            self.state = 268
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 264
                self.match(wktParser.COMMA)
                self.state = 265
                self.point()
                self.state = 270
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 271
            self.match(wktParser.RPAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PointOrClosedPointContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def point(self):
            return self.getTypedRuleContext(wktParser.PointContext,0)


        def LPAR(self):
            return self.getToken(wktParser.LPAR, 0)

        def RPAR(self):
            return self.getToken(wktParser.RPAR, 0)

        def getRuleIndex(self):
            return wktParser.RULE_pointOrClosedPoint

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPointOrClosedPoint" ):
                listener.enterPointOrClosedPoint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPointOrClosedPoint" ):
                listener.exitPointOrClosedPoint(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPointOrClosedPoint" ):
                return visitor.visitPointOrClosedPoint(self)
            else:
                return visitor.visitChildren(self)




    def pointOrClosedPoint(self):

        localctx = wktParser.PointOrClosedPointContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_pointOrClosedPoint)
        try:
            self.state = 278
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [1]:
                self.enterOuterAlt(localctx, 1)
                self.state = 273
                self.point()
                pass
            elif token in [5]:
                self.enterOuterAlt(localctx, 2)
                self.state = 274
                self.match(wktParser.LPAR)
                self.state = 275
                self.point()
                self.state = 276
                self.match(wktParser.RPAR)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolygonContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAR(self):
            return self.getToken(wktParser.LPAR, 0)

        def lineString(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(wktParser.LineStringContext)
            else:
                return self.getTypedRuleContext(wktParser.LineStringContext,i)


        def RPAR(self):
            return self.getToken(wktParser.RPAR, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(wktParser.COMMA)
            else:
                return self.getToken(wktParser.COMMA, i)

        def EMPTY_(self):
            return self.getToken(wktParser.EMPTY_, 0)

        def getRuleIndex(self):
            return wktParser.RULE_polygon

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolygon" ):
                listener.enterPolygon(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolygon" ):
                listener.exitPolygon(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPolygon" ):
                return visitor.visitPolygon(self)
            else:
                return visitor.visitChildren(self)




    def polygon(self):

        localctx = wktParser.PolygonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_polygon)
        self._la = 0 # Token type
        try:
            self.state = 292
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5]:
                self.enterOuterAlt(localctx, 1)
                self.state = 280
                self.match(wktParser.LPAR)
                self.state = 281
                self.lineString()
                self.state = 286
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==4:
                    self.state = 282
                    self.match(wktParser.COMMA)
                    self.state = 283
                    self.lineString()
                    self.state = 288
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 289
                self.match(wktParser.RPAR)
                pass
            elif token in [14]:
                self.enterOuterAlt(localctx, 2)
                self.state = 291
                self.match(wktParser.EMPTY_)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LineStringContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAR(self):
            return self.getToken(wktParser.LPAR, 0)

        def point(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(wktParser.PointContext)
            else:
                return self.getTypedRuleContext(wktParser.PointContext,i)


        def RPAR(self):
            return self.getToken(wktParser.RPAR, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(wktParser.COMMA)
            else:
                return self.getToken(wktParser.COMMA, i)

        def EMPTY_(self):
            return self.getToken(wktParser.EMPTY_, 0)

        def getRuleIndex(self):
            return wktParser.RULE_lineString

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLineString" ):
                listener.enterLineString(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLineString" ):
                listener.exitLineString(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLineString" ):
                return visitor.visitLineString(self)
            else:
                return visitor.visitChildren(self)




    def lineString(self):

        localctx = wktParser.LineStringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_lineString)
        self._la = 0 # Token type
        try:
            self.state = 306
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5]:
                self.enterOuterAlt(localctx, 1)
                self.state = 294
                self.match(wktParser.LPAR)
                self.state = 295
                self.point()
                self.state = 300
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==4:
                    self.state = 296
                    self.match(wktParser.COMMA)
                    self.state = 297
                    self.point()
                    self.state = 302
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 303
                self.match(wktParser.RPAR)
                pass
            elif token in [14]:
                self.enterOuterAlt(localctx, 2)
                self.state = 305
                self.match(wktParser.EMPTY_)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PointContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DECIMAL(self, i:int=None):
            if i is None:
                return self.getTokens(wktParser.DECIMAL)
            else:
                return self.getToken(wktParser.DECIMAL, i)

        def getRuleIndex(self):
            return wktParser.RULE_point

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPoint" ):
                listener.enterPoint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPoint" ):
                listener.exitPoint(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPoint" ):
                return visitor.visitPoint(self)
            else:
                return visitor.visitChildren(self)




    def point(self):

        localctx = wktParser.PointContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_point)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 309 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 308
                self.match(wktParser.DECIMAL)
                self.state = 311 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==1):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(wktParser.STRING, 0)

        def getRuleIndex(self):
            return wktParser.RULE_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterName" ):
                listener.enterName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitName" ):
                listener.exitName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitName" ):
                return visitor.visitName(self)
            else:
                return visitor.visitChildren(self)




    def name(self):

        localctx = wktParser.NameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 313
            self.match(wktParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





